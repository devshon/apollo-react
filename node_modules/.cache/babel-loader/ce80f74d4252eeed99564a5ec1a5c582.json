{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar lodash_1 = require(\"lodash\");\n\nvar builtinTypes = ['String', 'Float', 'Int', 'Boolean', 'ID'];\nvar builtinDirectives = ['deprecated', 'skip', 'include'];\n/**\n * Post processing of all imported type definitions. Loops over each of the\n * imported type definitions, and processes it using collectNewTypeDefinitions.\n *\n * @param allDefinitions All definitions from all schemas\n * @param definitionPool Current definitions (from first schema)\n * @param newTypeDefinitions All imported definitions\n * @returns Final collection of type definitions for the resulting schema\n */\n\nfunction completeDefinitionPool(allDefinitions, definitionPool, newTypeDefinitions) {\n  var visitedDefinitions = {};\n\n  while (newTypeDefinitions.length > 0) {\n    var schemaMap = lodash_1.keyBy(allDefinitions, function (d) {\n      return d.name.value;\n    });\n    var newDefinition = newTypeDefinitions.shift();\n\n    if (visitedDefinitions[newDefinition.name.value]) {\n      continue;\n    }\n\n    var collectedTypedDefinitions = collectNewTypeDefinitions(allDefinitions, definitionPool, newDefinition, schemaMap);\n    newTypeDefinitions.push.apply(newTypeDefinitions, collectedTypedDefinitions);\n    definitionPool.push.apply(definitionPool, collectedTypedDefinitions);\n    visitedDefinitions[newDefinition.name.value] = true;\n  }\n\n  return lodash_1.uniqBy(definitionPool, 'name.value');\n}\n\nexports.completeDefinitionPool = completeDefinitionPool;\n/**\n * Processes a single type definition, and performs a number of checks:\n * - Add missing interface implementations\n * - Add missing referenced types\n * - Remove unused type definitions\n *\n * @param allDefinitions All definitions from all schemas\n * (only used to find missing interface implementations)\n * @param definitionPool Resulting definitions\n * @param newDefinition All imported definitions\n * @param schemaMap Map of all definitions for easy lookup\n * @returns All relevant type definitions to add to the final schema\n */\n\nfunction collectNewTypeDefinitions(allDefinitions, definitionPool, newDefinition, schemaMap) {\n  var newTypeDefinitions = [];\n\n  if (newDefinition.kind !== 'DirectiveDefinition') {\n    newDefinition.directives.forEach(collectDirective);\n  }\n\n  if (newDefinition.kind === 'InputObjectTypeDefinition') {\n    newDefinition.fields.forEach(collectNode);\n  }\n\n  if (newDefinition.kind === 'InterfaceTypeDefinition') {\n    var interfaceName_1 = newDefinition.name.value;\n    newDefinition.fields.forEach(collectNode);\n    var interfaceImplementations = allDefinitions.filter(function (d) {\n      return d.kind === 'ObjectTypeDefinition' && d.interfaces.some(function (i) {\n        return i.name.value === interfaceName_1;\n      });\n    });\n    newTypeDefinitions.push.apply(newTypeDefinitions, interfaceImplementations);\n  }\n\n  if (newDefinition.kind === 'UnionTypeDefinition') {\n    newDefinition.types.forEach(function (type) {\n      if (!definitionPool.some(function (d) {\n        return d.name.value === type.name.value;\n      })) {\n        var typeName = type.name.value;\n        var typeMatch = schemaMap[typeName];\n\n        if (!typeMatch) {\n          throw new Error(\"Couldn't find type \" + typeName + \" in any of the schemas.\");\n        }\n\n        newTypeDefinitions.push(schemaMap[type.name.value]);\n      }\n    });\n  }\n\n  if (newDefinition.kind === 'ObjectTypeDefinition') {\n    // collect missing interfaces\n    newDefinition.interfaces.forEach(function (int) {\n      if (!definitionPool.some(function (d) {\n        return d.name.value === int.name.value;\n      })) {\n        var interfaceName = int.name.value;\n        var interfaceMatch = schemaMap[interfaceName];\n\n        if (!interfaceMatch) {\n          throw new Error(\"Couldn't find interface \" + interfaceName + \" in any of the schemas.\");\n        }\n\n        newTypeDefinitions.push(schemaMap[int.name.value]);\n      }\n    }); // iterate over all fields\n\n    newDefinition.fields.forEach(function (field) {\n      collectNode(field); // collect missing argument input types\n\n      field.arguments.forEach(collectNode);\n    });\n  }\n\n  return newTypeDefinitions;\n\n  function collectNode(node) {\n    var nodeType = getNamedType(node.type);\n    var nodeTypeName = nodeType.name.value; // collect missing argument input types\n\n    if (!definitionPool.some(function (d) {\n      return d.name.value === nodeTypeName;\n    }) && !lodash_1.includes(builtinTypes, nodeTypeName)) {\n      var argTypeMatch = schemaMap[nodeTypeName];\n\n      if (!argTypeMatch) {\n        throw new Error(\"Field \" + node.name.value + \": Couldn't find type \" + nodeTypeName + \" in any of the schemas.\");\n      }\n\n      newTypeDefinitions.push(argTypeMatch);\n    }\n\n    node.directives.forEach(collectDirective);\n  }\n\n  function collectDirective(directive) {\n    var directiveName = directive.name.value;\n\n    if (!definitionPool.some(function (d) {\n      return d.name.value === directiveName;\n    }) && !lodash_1.includes(builtinDirectives, directiveName)) {\n      var directive_1 = schemaMap[directiveName];\n\n      if (!directive_1) {\n        throw new Error(\"Directive \" + directiveName + \": Couldn't find type \" + directiveName + \" in any of the schemas.\");\n      }\n\n      directive_1.arguments.forEach(collectNode);\n      newTypeDefinitions.push(directive_1);\n    }\n  }\n}\n/**\n * Nested visitor for a type node to get to the final NamedType\n *\n * @param {TypeNode} type Type node to get NamedTypeNode for\n * @returns {NamedTypeNode} The found NamedTypeNode\n */\n\n\nfunction getNamedType(type) {\n  if (type.kind === 'NamedType') {\n    return type;\n  } else {\n    return getNamedType(type.type);\n  }\n}","map":{"version":3,"sources":["../src/definition.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar lodash_1 = require(\"lodash\");\nvar builtinTypes = ['String', 'Float', 'Int', 'Boolean', 'ID'];\nvar builtinDirectives = ['deprecated', 'skip', 'include'];\n/**\n * Post processing of all imported type definitions. Loops over each of the\n * imported type definitions, and processes it using collectNewTypeDefinitions.\n *\n * @param allDefinitions All definitions from all schemas\n * @param definitionPool Current definitions (from first schema)\n * @param newTypeDefinitions All imported definitions\n * @returns Final collection of type definitions for the resulting schema\n */\nfunction completeDefinitionPool(allDefinitions, definitionPool, newTypeDefinitions) {\n    var visitedDefinitions = {};\n    while (newTypeDefinitions.length > 0) {\n        var schemaMap = lodash_1.keyBy(allDefinitions, function (d) { return d.name.value; });\n        var newDefinition = newTypeDefinitions.shift();\n        if (visitedDefinitions[newDefinition.name.value]) {\n            continue;\n        }\n        var collectedTypedDefinitions = collectNewTypeDefinitions(allDefinitions, definitionPool, newDefinition, schemaMap);\n        newTypeDefinitions.push.apply(newTypeDefinitions, collectedTypedDefinitions);\n        definitionPool.push.apply(definitionPool, collectedTypedDefinitions);\n        visitedDefinitions[newDefinition.name.value] = true;\n    }\n    return lodash_1.uniqBy(definitionPool, 'name.value');\n}\nexports.completeDefinitionPool = completeDefinitionPool;\n/**\n * Processes a single type definition, and performs a number of checks:\n * - Add missing interface implementations\n * - Add missing referenced types\n * - Remove unused type definitions\n *\n * @param allDefinitions All definitions from all schemas\n * (only used to find missing interface implementations)\n * @param definitionPool Resulting definitions\n * @param newDefinition All imported definitions\n * @param schemaMap Map of all definitions for easy lookup\n * @returns All relevant type definitions to add to the final schema\n */\nfunction collectNewTypeDefinitions(allDefinitions, definitionPool, newDefinition, schemaMap) {\n    var newTypeDefinitions = [];\n    if (newDefinition.kind !== 'DirectiveDefinition') {\n        newDefinition.directives.forEach(collectDirective);\n    }\n    if (newDefinition.kind === 'InputObjectTypeDefinition') {\n        newDefinition.fields.forEach(collectNode);\n    }\n    if (newDefinition.kind === 'InterfaceTypeDefinition') {\n        var interfaceName_1 = newDefinition.name.value;\n        newDefinition.fields.forEach(collectNode);\n        var interfaceImplementations = allDefinitions.filter(function (d) {\n            return d.kind === 'ObjectTypeDefinition' &&\n                d.interfaces.some(function (i) { return i.name.value === interfaceName_1; });\n        });\n        newTypeDefinitions.push.apply(newTypeDefinitions, interfaceImplementations);\n    }\n    if (newDefinition.kind === 'UnionTypeDefinition') {\n        newDefinition.types.forEach(function (type) {\n            if (!definitionPool.some(function (d) { return d.name.value === type.name.value; })) {\n                var typeName = type.name.value;\n                var typeMatch = schemaMap[typeName];\n                if (!typeMatch) {\n                    throw new Error(\"Couldn't find type \" + typeName + \" in any of the schemas.\");\n                }\n                newTypeDefinitions.push(schemaMap[type.name.value]);\n            }\n        });\n    }\n    if (newDefinition.kind === 'ObjectTypeDefinition') {\n        // collect missing interfaces\n        newDefinition.interfaces.forEach(function (int) {\n            if (!definitionPool.some(function (d) { return d.name.value === int.name.value; })) {\n                var interfaceName = int.name.value;\n                var interfaceMatch = schemaMap[interfaceName];\n                if (!interfaceMatch) {\n                    throw new Error(\"Couldn't find interface \" + interfaceName + \" in any of the schemas.\");\n                }\n                newTypeDefinitions.push(schemaMap[int.name.value]);\n            }\n        });\n        // iterate over all fields\n        newDefinition.fields.forEach(function (field) {\n            collectNode(field);\n            // collect missing argument input types\n            field.arguments.forEach(collectNode);\n        });\n    }\n    return newTypeDefinitions;\n    function collectNode(node) {\n        var nodeType = getNamedType(node.type);\n        var nodeTypeName = nodeType.name.value;\n        // collect missing argument input types\n        if (!definitionPool.some(function (d) { return d.name.value === nodeTypeName; }) &&\n            !lodash_1.includes(builtinTypes, nodeTypeName)) {\n            var argTypeMatch = schemaMap[nodeTypeName];\n            if (!argTypeMatch) {\n                throw new Error(\"Field \" + node.name.value + \": Couldn't find type \" + nodeTypeName + \" in any of the schemas.\");\n            }\n            newTypeDefinitions.push(argTypeMatch);\n        }\n        node.directives.forEach(collectDirective);\n    }\n    function collectDirective(directive) {\n        var directiveName = directive.name.value;\n        if (!definitionPool.some(function (d) { return d.name.value === directiveName; }) &&\n            !lodash_1.includes(builtinDirectives, directiveName)) {\n            var directive_1 = schemaMap[directiveName];\n            if (!directive_1) {\n                throw new Error(\"Directive \" + directiveName + \": Couldn't find type \" + directiveName + \" in any of the schemas.\");\n            }\n            directive_1.arguments.forEach(collectNode);\n            newTypeDefinitions.push(directive_1);\n        }\n    }\n}\n/**\n * Nested visitor for a type node to get to the final NamedType\n *\n * @param {TypeNode} type Type node to get NamedTypeNode for\n * @returns {NamedTypeNode} The found NamedTypeNode\n */\nfunction getNamedType(type) {\n    if (type.kind === 'NamedType') {\n        return type;\n    }\n    else {\n        return getNamedType(type.type);\n    }\n}\n//# sourceMappingURL=definition.js.map"]},"metadata":{},"sourceType":"script"}