{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nvar TracingExtension =\n/** @class */\nfunction () {\n  function TracingExtension() {\n    this.resolverCalls = [];\n  }\n\n  TracingExtension.prototype.requestDidStart = function () {\n    this.startWallTime = new Date();\n    this.startHrTime = process.hrtime();\n  };\n\n  TracingExtension.prototype.executionDidStart = function () {};\n\n  TracingExtension.prototype.willResolveField = function (_source, _args, _context, info) {\n    var _this = this;\n\n    var resolverCall = {\n      path: info.path,\n      fieldName: info.fieldName,\n      parentType: info.parentType,\n      returnType: info.returnType,\n      startOffset: process.hrtime(this.startHrTime)\n    };\n    this.resolverCalls.push(resolverCall);\n    return function () {\n      resolverCall.endOffset = process.hrtime(_this.startHrTime);\n    };\n  };\n\n  TracingExtension.prototype.didResolveField = function (_source, _args, _context, info) {};\n\n  TracingExtension.prototype.requestDidEnd = function () {\n    this.duration = process.hrtime(this.startHrTime);\n    this.endWallTime = new Date();\n  };\n\n  TracingExtension.prototype.format = function () {\n    // In the event that we are called prior to the initialization of critical\n    // date metrics, we'll return undefined to signal that the extension did not\n    // format properly.  Any undefined extension results are simply purged by\n    // the graphql-extensions module.\n    if (typeof this.startWallTime === \"undefined\" || typeof this.endWallTime === \"undefined\" || typeof this.duration === \"undefined\") {\n      return;\n    }\n\n    return [\"tracing\", {\n      version: 1,\n      startTime: this.startWallTime.toISOString(),\n      endTime: this.endWallTime.toISOString(),\n      duration: durationHrTimeToNanos(this.duration),\n      execution: {\n        resolvers: this.resolverCalls.map(function (resolverCall) {\n          var startOffset = durationHrTimeToNanos(resolverCall.startOffset);\n          var duration = resolverCall.endOffset ? durationHrTimeToNanos(resolverCall.endOffset) - startOffset : 0;\n          return {\n            path: graphql_1.responsePathAsArray(resolverCall.path),\n            parentType: resolverCall.parentType.toString(),\n            fieldName: resolverCall.fieldName,\n            returnType: resolverCall.returnType.toString(),\n            startOffset: startOffset,\n            duration: duration\n          };\n        })\n      }\n    }];\n  };\n\n  return TracingExtension;\n}();\n\nexports.TracingExtension = TracingExtension; // Converts an hrtime array (as returned from process.hrtime) to nanoseconds.\n//\n// ONLY CALL THIS ON VALUES REPRESENTING DELTAS, NOT ON THE RAW RETURN VALUE\n// FROM process.hrtime() WITH NO ARGUMENTS.\n//\n// The entire point of the hrtime data structure is that the JavaScript Number\n// type can't represent all int64 values without loss of precision:\n// Number.MAX_SAFE_INTEGER nanoseconds is about 104 days. Calling this function\n// on a duration that represents a value less than 104 days is fine. Calling\n// this function on an absolute time (which is generally roughly time since\n// system boot) is not a good idea.\n\nfunction durationHrTimeToNanos(hrtime) {\n  return hrtime[0] * 1e9 + hrtime[1];\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = require(\"graphql\");\nvar TracingExtension = /** @class */ (function () {\n    function TracingExtension() {\n        this.resolverCalls = [];\n    }\n    TracingExtension.prototype.requestDidStart = function () {\n        this.startWallTime = new Date();\n        this.startHrTime = process.hrtime();\n    };\n    TracingExtension.prototype.executionDidStart = function () { };\n    TracingExtension.prototype.willResolveField = function (_source, _args, _context, info) {\n        var _this = this;\n        var resolverCall = {\n            path: info.path,\n            fieldName: info.fieldName,\n            parentType: info.parentType,\n            returnType: info.returnType,\n            startOffset: process.hrtime(this.startHrTime)\n        };\n        this.resolverCalls.push(resolverCall);\n        return function () {\n            resolverCall.endOffset = process.hrtime(_this.startHrTime);\n        };\n    };\n    TracingExtension.prototype.didResolveField = function (_source, _args, _context, info) { };\n    TracingExtension.prototype.requestDidEnd = function () {\n        this.duration = process.hrtime(this.startHrTime);\n        this.endWallTime = new Date();\n    };\n    TracingExtension.prototype.format = function () {\n        // In the event that we are called prior to the initialization of critical\n        // date metrics, we'll return undefined to signal that the extension did not\n        // format properly.  Any undefined extension results are simply purged by\n        // the graphql-extensions module.\n        if (typeof this.startWallTime === \"undefined\" ||\n            typeof this.endWallTime === \"undefined\" ||\n            typeof this.duration === \"undefined\") {\n            return;\n        }\n        return [\n            \"tracing\",\n            {\n                version: 1,\n                startTime: this.startWallTime.toISOString(),\n                endTime: this.endWallTime.toISOString(),\n                duration: durationHrTimeToNanos(this.duration),\n                execution: {\n                    resolvers: this.resolverCalls.map(function (resolverCall) {\n                        var startOffset = durationHrTimeToNanos(resolverCall.startOffset);\n                        var duration = resolverCall.endOffset\n                            ? durationHrTimeToNanos(resolverCall.endOffset) - startOffset\n                            : 0;\n                        return {\n                            path: graphql_1.responsePathAsArray(resolverCall.path),\n                            parentType: resolverCall.parentType.toString(),\n                            fieldName: resolverCall.fieldName,\n                            returnType: resolverCall.returnType.toString(),\n                            startOffset: startOffset,\n                            duration: duration\n                        };\n                    })\n                }\n            }\n        ];\n    };\n    return TracingExtension;\n}());\nexports.TracingExtension = TracingExtension;\n// Converts an hrtime array (as returned from process.hrtime) to nanoseconds.\n//\n// ONLY CALL THIS ON VALUES REPRESENTING DELTAS, NOT ON THE RAW RETURN VALUE\n// FROM process.hrtime() WITH NO ARGUMENTS.\n//\n// The entire point of the hrtime data structure is that the JavaScript Number\n// type can't represent all int64 values without loss of precision:\n// Number.MAX_SAFE_INTEGER nanoseconds is about 104 days. Calling this function\n// on a duration that represents a value less than 104 days is fine. Calling\n// this function on an absolute time (which is generally roughly time since\n// system boot) is not a good idea.\nfunction durationHrTimeToNanos(hrtime) {\n    return hrtime[0] * 1e9 + hrtime[1];\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}