{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst graphql_1 = require(\"graphql\");\n\nfunction extractFragmentReplacements(resolvers) {\n  const allFragmentReplacements = [];\n  /* Collect fragments. */\n\n  for (const typeName in resolvers) {\n    const fieldResolvers = resolvers[typeName];\n\n    for (const fieldName in fieldResolvers) {\n      const fieldResolver = fieldResolvers[fieldName];\n\n      if (typeof fieldResolver === 'object' && fieldResolver.fragment) {\n        allFragmentReplacements.push({\n          field: fieldName,\n          fragment: fieldResolver.fragment\n        });\n      }\n\n      if (typeof fieldResolver === 'object' && fieldResolver.fragments) {\n        for (const fragment of fieldResolver.fragments) {\n          allFragmentReplacements.push({\n            field: fieldName,\n            fragment: fragment\n          });\n        }\n      }\n    }\n  }\n  /* Filter and map circular dependencies. */\n\n\n  const fragmentReplacements = allFragmentReplacements.filter(fragment => Boolean(fragment)).map(fragmentReplacement => {\n    const fragment = parseFragmentToInlineFragment(fragmentReplacement.fragment);\n    const newSelections = fragment.selectionSet.selections.filter(node => {\n      switch (node.kind) {\n        case graphql_1.Kind.FIELD:\n          {\n            return node.name.value !== fragmentReplacement.field;\n          }\n\n        default:\n          {\n            return true;\n          }\n      }\n    });\n\n    if (newSelections.length === 0) {\n      return null;\n    }\n\n    const newFragment = Object.assign({}, fragment, {\n      selectionSet: {\n        kind: fragment.selectionSet.kind,\n        loc: fragment.selectionSet.loc,\n        selections: newSelections\n      }\n    });\n    const parsedFragment = graphql_1.print(newFragment);\n    return {\n      field: fragmentReplacement.field,\n      fragment: parsedFragment\n    };\n  }).filter(fr => fr !== null);\n  return fragmentReplacements;\n  /* Helper functions */\n\n  function parseFragmentToInlineFragment(definitions) {\n    if (definitions.trim().startsWith('fragment')) {\n      const document = graphql_1.parse(definitions);\n\n      for (const definition of document.definitions) {\n        if (definition.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {\n          return {\n            kind: graphql_1.Kind.INLINE_FRAGMENT,\n            typeCondition: definition.typeCondition,\n            selectionSet: definition.selectionSet\n          };\n        }\n      }\n    }\n\n    const query = graphql_1.parse(`{${definitions}}`).definitions[0];\n\n    for (const selection of query.selectionSet.selections) {\n      if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {\n        return selection;\n      }\n    }\n\n    throw new Error('Could not parse fragment');\n  }\n}\n\nexports.extractFragmentReplacements = extractFragmentReplacements;","map":{"version":3,"sources":["../src/fragments.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst graphql_1 = require(\"graphql\");\nfunction extractFragmentReplacements(resolvers) {\n    const allFragmentReplacements = [];\n    /* Collect fragments. */\n    for (const typeName in resolvers) {\n        const fieldResolvers = resolvers[typeName];\n        for (const fieldName in fieldResolvers) {\n            const fieldResolver = fieldResolvers[fieldName];\n            if (typeof fieldResolver === 'object' && fieldResolver.fragment) {\n                allFragmentReplacements.push({\n                    field: fieldName,\n                    fragment: fieldResolver.fragment,\n                });\n            }\n            if (typeof fieldResolver === 'object' && fieldResolver.fragments) {\n                for (const fragment of fieldResolver.fragments) {\n                    allFragmentReplacements.push({\n                        field: fieldName,\n                        fragment: fragment,\n                    });\n                }\n            }\n        }\n    }\n    /* Filter and map circular dependencies. */\n    const fragmentReplacements = allFragmentReplacements\n        .filter(fragment => Boolean(fragment))\n        .map(fragmentReplacement => {\n        const fragment = parseFragmentToInlineFragment(fragmentReplacement.fragment);\n        const newSelections = fragment.selectionSet.selections.filter(node => {\n            switch (node.kind) {\n                case graphql_1.Kind.FIELD: {\n                    return node.name.value !== fragmentReplacement.field;\n                }\n                default: {\n                    return true;\n                }\n            }\n        });\n        if (newSelections.length === 0) {\n            return null;\n        }\n        const newFragment = Object.assign({}, fragment, { selectionSet: {\n                kind: fragment.selectionSet.kind,\n                loc: fragment.selectionSet.loc,\n                selections: newSelections,\n            } });\n        const parsedFragment = graphql_1.print(newFragment);\n        return {\n            field: fragmentReplacement.field,\n            fragment: parsedFragment,\n        };\n    })\n        .filter(fr => fr !== null);\n    return fragmentReplacements;\n    /* Helper functions */\n    function parseFragmentToInlineFragment(definitions) {\n        if (definitions.trim().startsWith('fragment')) {\n            const document = graphql_1.parse(definitions);\n            for (const definition of document.definitions) {\n                if (definition.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {\n                    return {\n                        kind: graphql_1.Kind.INLINE_FRAGMENT,\n                        typeCondition: definition.typeCondition,\n                        selectionSet: definition.selectionSet,\n                    };\n                }\n            }\n        }\n        const query = graphql_1.parse(`{${definitions}}`)\n            .definitions[0];\n        for (const selection of query.selectionSet.selections) {\n            if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {\n                return selection;\n            }\n        }\n        throw new Error('Could not parse fragment');\n    }\n}\nexports.extractFragmentReplacements = extractFragmentReplacements;\n//# sourceMappingURL=fragments.js.map"]},"metadata":{},"sourceType":"script"}